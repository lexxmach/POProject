# Yet Another UrlShortener

Очердной PoC сокращатель ссылок, с **overhead** фичами

### Что умеем

1. Все `REST API` находится под контролем фреймеворка [Huma](https://github.com/danielgtaylor/huma), который кодгенит `openapi`, `swagger` и прочий шлак
2. Все работа с БД находится под контролем `gorm`, а это означает автоматические миграции, а также легкую смену баз данных
3. Deploy через докер-композ, который хелфчекает БД и сам сервис, рестартает на ошибке, а также не поднимает сервис пока БД не встала
4. Умеем подниматься локально с замоканной БД, без всяких умных докер-композов, все *in-memory*, без персистентности относительно запусков
5. Покрыто тестам, с божьей помощью
6. **KILLER-FEATURE**: `Validation webhook`, почти такие же как у кубера. Любой запрос по данной сокращенной ссылке будет валидироваться, и если он отклонен, то пользователю будет писаться сообщение об ошибке. 

### Как пользоваться
1. **Сокращаем ссылку по пути `/create`**
   1. Отсылается `POST` с ссылкой и *опционально* validation webhook
    Пример:
    ```bash
        curl --request POST \
        --url http://localhost:8000/create \
        --data '{
            "url": "http://google.com",
            "webhook": "http://localhost:8001/verify"
        }'"
    ```
    2. Получаем **три** важные вещи: ключик, куда ходить, а также `Authorization` header
    ```json
    {
        "key": "rkkMN",
        "url": "localhost:8000/follow/rkkMN"
    }
    Authorization: somekey.jwt
    ```
    3. Все под валидацией, закинуть неправильный `url` нельзя
2. **Ходим по ссылке по пути `/follow`**
    1. Посылаем `GET` запрос по пути `/follow/{key}`, который получили до этого, либо ходим честно через `url`, полученные от `create`
    2. Нам присылается `HTTP 301`, и новая локация, если вебхук не указан
    3. Если вебхук указан, то сначала отправляется запрос туда
        1. Если вебхук не ответил `HTTP OK`, то фейлимся без шансов, без логов пользователю
        2. Если вебхук ответил, при этом `pass: true`, пропускаем
        3. Если вебхук ответил, при этом `pass: false`, отдаем пользователю ошибку из `reason` поля ответа вебхука
3. **Используем токен**
    1. `HTTP DELETE /delete/webhook/{key}`
    Нетрудно догадаться, что удаляет только вебхук у выбранного ключа, сам `URL` остается без изменений.
    2. `HTTP DELETE /delete/{key}`
    Также тривиально, удаляет ключик вообще из рассмотрения, все следующие `/follorw/{key}` будут возвращять `HTTP 400`
    3. Все эти действия возмонжы только под `Authorization` хедером, отправленном при `create`, на неавторизавнное действие возвращаем `HTTP 401`
4. **Пишем вебхуки**
    1. При вызове `/create` ставим наш вебхук
    2. Логика вебхука следующая, берутся **все** хедеры оригинального запроса, и отправлются с **нашего** сервера на этот вебхук. Т.е валидацию по агенту/кукам можно написать, а вот айпишник так уже нельзя получить
    3. Вебхук отдает простую жысонину следующего формата
    ```go
    type WebHookResponse struct {
        Pass   bool   `json:"pass"`
        Reason string `json:"reason"`
    }
    ```
    4. Если `pass=false`, то `Reason` будет выведено пользователю, почему его не пустили
5. **Деплоим и трогаем**
    1. Если не хочется трогать докеры, то можно запустить на локальной машине, главное у конфига сделать `"db.mock" = true`
    2. Если мы взрослые ребята, залезаем в `POProject/deploy` и делаем `docker-compose up -d`, он автоматически поднимет сервис с постгрей, порт указан в конфиге по пути `configs/shortener.json`
    3. Вебхук example написан в `examples/webhook.go`, поднять его можно также локально `go run examples/webhook.go`

### Что хочется, но ручки устали

1. Очевидный *flaw* данной машинерии это то, что ключи не протухают, а при удалении вообще могут заняться кем-то другим.
Как чинить понятно, не очень понятно нужно ли
2. Кеша на `gorm` нет, руками писать западлу
Нужно написать `thread-safe` кэшик, который протухает на мутирующих методах `URLDatabase`, и прогревает на немутирующих. Зачем надо - непонятно, из коробки ничего нет, дающие адекватные гарантии
3. Непонятно что делать если вебхук упал на запрос. 
По-хорошему нужно пробросить опцию в `/create`, но ручки устали (я кстати ненавижу го)
4. Статистика из коробки, а не руками в вебхуке. 
В теории можно и в вебхуке, но тогда вебхук должен агрегировать другие хуки, в итоге получили сервис в сервисе, слишком плохо.
Фикс этого: передавать список вебхуков, но ради одного хопа делать адовую машину, непонятно стоит ли
5. **KUBERNETES**
без слов, я и так этим на работе занимаюсь, впадлу
6. Тесты. 
Очень впадлу было переходить с горма и руками писать миграции/sql. Однако всплыл великий [issue](https://github.com/go-gorm/gorm/issues/3565), очевидно он closed потому что старый, вычитывать что там происходит западлу. Сейчас работает под докер-контейнером постгри, что `doubtful but okey`
7. Причесать код
Но вроде и так не сильно плохо
8. GRPC? 
Я лично не фанат, но задача кажется просто на очередную перекладку проток в жысон и обратно.
9. Динконфиги
Должно завестить из под коробки, но опять же непонятно насколько надо.